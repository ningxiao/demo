<!DOCTYPE html>
<html lang="en">

<head>
    <title>图片粒子效果</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f7f7fd;
        }

        .flex-center {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 100%;
            height: 100%;
        }

        img {
            width: 15rem !important;
            cursor: pointer;
            position: absolute;
        }

    </style>
</head>

<body>
    <div class="container flex-center"></div>
    <script src="js/WebGL.js"></script>
    <script type="module">
        import gsap from "https://cdn.skypack.dev/gsap@3.6.0";
        import * as dat from "https://cdn.skypack.dev/dat.gui@0.7.7";
        import Stats from "https://cdn.skypack.dev/three@0.124.0/examples/jsm/libs/stats.module";
        import * as THREE from "https://cdn.skypack.dev/three@0.124.0";
        import {
            OrbitControls
        } from "https://cdn.skypack.dev/three@0.124.0/examples/jsm/controls/OrbitControls";
        import {
            EffectComposer
        } from "https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/EffectComposer";
        import {
            RenderPass
        } from "https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/RenderPass";
        import {
            UnrealBloomPass
        } from "https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/UnrealBloomPass";

        const calcAspect = (el) => el.clientWidth / el.clientHeight;
        const getNormalizedMousePos = (e) => {
            return {
                x: (e.clientX / window.innerWidth) * 2 - 1,
                y: -(e.clientY / window.innerHeight) * 2 + 1
            };
        };
        const particleExplodeVertexShader = `
vec4 permute(vec4 x){return mod(((x*34.)+1.)*x,289.);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}

float snoise(vec3 v){
    const vec2 C=vec2(1./6.,1./3.);
    const vec4 D=vec4(0.,.5,1.,2.);

    // First corner
    vec3 i=floor(v+dot(v,C.yyy));
    vec3 x0=v-i+dot(i,C.xxx);

    // Other corners
    vec3 g=step(x0.yzx,x0.xyz);
    vec3 l=1.-g;
    vec3 i1=min(g.xyz,l.zxy);
    vec3 i2=max(g.xyz,l.zxy);

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1=x0-i1+1.*C.xxx;
    vec3 x2=x0-i2+2.*C.xxx;
    vec3 x3=x0-1.+3.*C.xxx;

    // Permutations
    i=mod(i,289.);
    vec4 p=permute(permute(permute(
                i.z+vec4(0.,i1.z,i2.z,1.))
                +i.y+vec4(0.,i1.y,i2.y,1.))
                +i.x+vec4(0.,i1.x,i2.x,1.));

                // Gradients
                // ( N*N points uniformly over a square, mapped onto an octahedron.)
                float n_=1./7.;// N=7
                vec3 ns=n_*D.wyz-D.xzx;

                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,N*N)

                vec4 x_=floor(j*ns.z);
                vec4 y_=floor(j-7.*x_);// mod(j,N)

                vec4 x=x_*ns.x+ns.yyyy;
                vec4 y=y_*ns.x+ns.yyyy;
                vec4 h=1.-abs(x)-abs(y);

                vec4 b0=vec4(x.xy,y.xy);
                vec4 b1=vec4(x.zw,y.zw);

                vec4 s0=floor(b0)*2.+1.;
                vec4 s1=floor(b1)*2.+1.;
                vec4 sh=-step(h,vec4(0.));

                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;
                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;

                vec3 p0=vec3(a0.xy,h.x);
                vec3 p1=vec3(a0.zw,h.y);
                vec3 p2=vec3(a1.xy,h.z);
                vec3 p3=vec3(a1.zw,h.w);

                //Normalise gradients
                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
                p0*=norm.x;
                p1*=norm.y;
                p2*=norm.z;
                p3*=norm.w;

                // Mix final noise value
                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);
                m=m*m;
                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),
                dot(p2,x2),dot(p3,x3)));
            }

            vec3 snoiseVec3(vec3 x){
                return vec3(snoise(vec3(x)*2.-1.),
                snoise(vec3(x.y-19.1,x.z+33.4,x.x+47.2))*2.-1.,
                snoise(vec3(x.z+74.2,x.x-124.5,x.y+99.4)*2.-1.)
            );
        }

        vec3 curlNoise(vec3 p){
            const float e=.1;
            vec3 dx=vec3(e,0.,0.);
            vec3 dy=vec3(0.,e,0.);
            vec3 dz=vec3(0.,0.,e);

            vec3 p_x0=snoiseVec3(p-dx);
            vec3 p_x1=snoiseVec3(p+dx);
            vec3 p_y0=snoiseVec3(p-dy);
            vec3 p_y1=snoiseVec3(p+dy);
            vec3 p_z0=snoiseVec3(p-dz);
            vec3 p_z1=snoiseVec3(p+dz);

            float x=p_y1.z-p_y0.z-p_z1.y+p_z0.y;
            float y=p_z1.x-p_z0.x-p_x1.z+p_x0.z;
            float z=p_x1.y-p_x0.y-p_y1.x+p_y0.x;

            const float divisor=1./(2.*e);
            return normalize(vec3(x,y,z)*divisor);
        }

        uniform float uTime;
        uniform float uProgress;
        varying vec2 vUv;

        void main(){
            vec3 noise=curlNoise(vec3(position.x*.02,position.y*.008,uTime*.05));
            vec3 distortion=vec3(position.x*2.,position.y,1.)*noise*uProgress;
            vec3 newPos=position+distortion;
            vec4 modelPosition=modelMatrix*vec4(newPos,1.);
            vec4 viewPosition=viewMatrix*modelPosition;
            vec4 projectedPosition=projectionMatrix*viewPosition;
            gl_Position=projectedPosition;
            gl_PointSize=2.;

            vUv=uv;
        }
`;
        const particleExplodeFragmentShader = `
uniform float uTime;
uniform vec2 uMouse;
uniform vec2 uResolution;
uniform sampler2D uTexture;

varying vec2 vUv;

void main(){
    vec4 color=texture2D(uTexture,vUv);
    if(color.r<.1&&color.g<.1&&color.b<.1){
        discard;
    }
    gl_FragColor=color;
}
`;
        class Maku {
            el; // 图片元素
            rect; // 图片元素矩阵
            mesh; // 网格
            constructor(
                el,
                material,
                scene,
                meshType = 'mesh',
                meshSizeType = 'size',
                segments = {
                    width: 64,
                    height: 64,
                }
            ) {
                this.el = el;
                const texture = new THREE.Texture(el);
                texture.needsUpdate = true;
                const materialCopy = material.clone();
                materialCopy.uniforms.uTexture.value = texture;
                const rect = el.getBoundingClientRect();
                const {
                    width,
                    height
                } = rect;
                this.rect = rect;
                const geometryMap = {
                    size: new THREE.PlaneBufferGeometry(
                        width,
                        height,
                        segments.width,
                        segments.height
                    ),
                    scale: new THREE.PlaneBufferGeometry(
                        1,
                        1,
                        segments.width,
                        segments.height
                    ),
                };
                const geometry = geometryMap[meshSizeType];
                const meshMap = {
                    points: new THREE.Points(geometry, materialCopy),
                    mesh: new THREE.Mesh(geometry, materialCopy),
                };
                const mesh = meshMap[meshType];
                if (meshSizeType === "scale") {
                    mesh.scale.set(width, height, 1);
                }
                scene.add(mesh);
                this.mesh = mesh;
            }
            // 同步位置
            setPosition(deltaY = window.scrollY) {
                const {
                    mesh,
                    rect
                } = this;
                const {
                    top,
                    left,
                    width,
                    height
                } = rect;
                const x = left + width / 2 - window.innerWidth / 2;
                const y = -(top + height / 2 - window.innerHeight / 2) + deltaY;
                mesh.position.set(x, y, 0);
            }
        }
        class Base {
            stats;
            debug;
            scene;
            camera;
            container;
            renderer;
            controls;
            mousePos;
            raycaster;
            mouseSpeed = 0;
            mousePos = new THREE.Vector2(0, 0);
            lookAtPosition = new THREE.Vector3(0, 0, 0);
            cameraPosition = new THREE.Vector3(0, 3, 10);
            perspectiveCameraParams = {
                fov: 75,
                near: 0.1,
                far: 100
            };
            orthographicCameraParams = {
                zoom: 2,
                near: -100,
                far: 1000
            };
            rendererParams = {
                outputEncoding: THREE.LinearEncoding,
                config: {
                    alpha: true,
                    antialias: true
                }
            };
            constructor(dom, debug = false) {
                this.debug = debug;
                this.container = dom;
            }
            // 初始化
            init() {
                this.createScene();
                this.createPerspectiveCamera();
                this.createRenderer();
                this.createMesh({});
                this.createLight();
                this.createOrbitControls();
                this.addListeners();
                this.setLoop();
            }
            // 创建场景
            createScene() {
                this.scene = new THREE.Scene();
                if (this.debug) {
                    this.stats = Stats();
                    this.scene.add(new THREE.AxesHelper());
                    this.container.appendChild(this.stats.dom);
                }
            }
            // 创建透视相机
            createPerspectiveCamera() {
                const {
                    fov,
                    near,
                    far
                } = this.perspectiveCameraParams;
                const aspect = calcAspect(this.container);
                this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                this.camera.position.copy(this.cameraPosition);
                this.camera.lookAt(this.lookAtPosition);
            }
            // 创建正交相机
            createOrthographicCamera() {
                const {
                    left,
                    right,
                    top,
                    bottom,
                    near,
                    far
                } = this.orthographicCameraParams;
                this.camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
                this.camera.position.copy(this.cameraPosition);
                this.camera.lookAt(this.lookAtPosition);
            }
            // 更新正交相机参数
            updateOrthographicCameraParams() {
                const {
                    zoom,
                    near,
                    far
                } = this.orthographicCameraParams;
                const aspect = calcAspect(this.container);
                this.orthographicCameraParams = {
                    left: -zoom * aspect,
                    right: zoom * aspect,
                    top: zoom,
                    bottom: -zoom,
                    near,
                    far,
                    zoom
                };
            }
            // 创建渲染
            createRenderer(useWebGL1 = false) {
                const {
                    outputEncoding,
                    config
                } = this.rendererParams;
                this.renderer = !useWebGL1 ? new THREE.WebGLRenderer(config) : new THREE.WebGL1Renderer(config);
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.outputEncoding = outputEncoding;
                this.resizeRendererToDisplaySize();
                this.container.appendChild(this.renderer.domElement);
                this.renderer.setClearColor(0x000000, 0);
            }
            // 允许投影
            enableShadow() {
                this.renderer.shadowMap.enabled = true;
            }
            // 调整渲染器尺寸
            resizeRendererToDisplaySize() {
                if (!this.renderer) {
                    return;
                }
                const canvas = this.renderer.domElement;
                const pixelRatio = window.devicePixelRatio;
                const {
                    clientWidth,
                    clientHeight
                } = canvas;
                const width = (clientWidth * pixelRatio) | 0;
                const height = (clientHeight * pixelRatio) | 0;
                const isResizeNeeded = canvas.width !== width || canvas.height !== height;
                if (isResizeNeeded) {
                    this.renderer.setSize(width, height, false);
                }
                return isResizeNeeded;
            }
            // 创建网格
            createMesh(meshObject, container = this.scene) {
                const {
                    geometry = new THREE.BoxGeometry(1, 1, 1),
                        material = new THREE.MeshStandardMaterial({
                            color: new THREE.Color("#d9dfc8")
                        }),
                        position = new THREE.Vector3(0, 0, 0)
                } = meshObject;
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                container.add(mesh);
                return mesh;
            }
            // 创建光源
            createLight() {
                const dirLight = new THREE.DirectionalLight(new THREE.Color("#ffffff"), 0.5);
                dirLight.position.set(0, 50, 0);
                this.scene.add(dirLight);
                const ambiLight = new THREE.AmbientLight(new THREE.Color("#ffffff"), 0.4);
                this.scene.add(ambiLight);
            }
            // 创建轨道控制
            createOrbitControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.copy(this.lookAtPosition);
                this.controls.update();
            }
            // 监听事件
            addListeners() {
                this.onResize();
            }
            // 监听画面缩放
            onResize() {
                window.addEventListener("resize", (e) => {
                    if (this.camera instanceof THREE.PerspectiveCamera) {
                        const aspect = calcAspect(this.container);
                        this.camera.aspect = aspect;
                        this.camera.updateProjectionMatrix();
                    } else if (this.camera instanceof THREE.OrthographicCamera) {
                        this.updateOrthographicCameraParams();
                        const {
                            left,
                            right,
                            top,
                            bottom,
                            near,
                            far
                        } = this.orthographicCameraParams;
                        this.camera.left = left;
                        this.camera.right = right;
                        this.camera.top = top;
                        this.camera.bottom = bottom;
                        this.camera.near = near;
                        this.camera.far = far;
                        this.camera.updateProjectionMatrix();
                    }
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                });
            }
            // 动画
            update() {
                console.log("animation");
            }
            // 渲染
            setLoop() {
                this.renderer.setAnimationLoop(() => {
                    this.resizeRendererToDisplaySize();
                    this.update();
                    if (this.controls) {
                        this.controls.update();
                    }
                    if (this.stats) {
                        this.stats.update();
                    }
                    if (this.composer) {
                        this.composer.render();
                    } else {
                        this.renderer.render(this.scene, this.camera);
                    }
                });
            }
            // 创建文本
            createText(
                text = "",
                config,
                material = new THREE.MeshStandardMaterial({
                    color: "#ffffff"
                })
            ) {
                return new THREE.Mesh(new THREE.TextGeometry(text, config), material);
            }
            // 追踪鼠标位置
            trackMousePos() {
                window.addEventListener("mousemove", (e) => {
                    this.setMousePos(e);
                });
                window.addEventListener("mouseout", () => {
                    this.clearMousePos();
                });
                window.addEventListener("mouseleave", () => {
                    this.clearMousePos();
                });
                window.addEventListener("touchstart", (e) => {
                    this.setMousePos(e.touches[0]);
                }, {
                    passive: false
                });
                window.addEventListener("touchmove", (e) => {
                    this.setMousePos(e.touches[0]);
                });
                window.addEventListener("touchend", () => {
                    this.clearMousePos();
                });
            }
            // 设置鼠标位置
            setMousePos(e) {
                const {
                    x,
                    y
                } = getNormalizedMousePos(e);
                this.mousePos.x = x;
                this.mousePos.y = y;
            }
            // 清空鼠标位置
            clearMousePos() {
                this.mousePos.x = -100000;
                this.mousePos.y = -100000;
            }
        }
        class ParticleExplode extends Base {
            params;
            image;
            maku;
            composer;
            bloomPass;
            isOpen = false;
            particleExplodeMaterial;
            perspectiveCameraParams;
            clock = new THREE.Clock();
            cameraPosition = new THREE.Vector3(0, 0, 1500);
            params = {
                exposure: 1,
                bloomStrength: 0,
                bloomThreshold: 0,
                bloomRadius: 0
            };
            constructor(dom, img, debug) {
                super(dom, debug);
                this.image = img;
                this.perspectiveCameraParams = {
                    fov: this.getScreenFov(this.cameraPosition.z),
                    near: 0.1,
                    far: 5000
                };
            }
            // 初始化
            init() {
                this.createScene();
                this.createPerspectiveCamera();
                this.createRenderer();
                this.createParticleExplodeMaterial();
                this.createPoints();
                this.createPostprocessingEffect();
                this.createClickEffect();
                this.createLight();
                this.trackMousePos();
                this.createOrbitControls();
                this.createDebugPanel();
                this.addListeners();
                this.setLoop();
            }
            // 获取跟屏幕同像素的fov角度
            getScreenFov(z) {
                return THREE.MathUtils.radToDeg(2 * Math.atan(window.innerHeight / 2 / z));
            }
            // 创建材质
            createParticleExplodeMaterial() {
                const particleExplodeMaterial = new THREE.ShaderMaterial({
                    vertexShader: particleExplodeVertexShader,
                    fragmentShader: particleExplodeFragmentShader,
                    side: THREE.DoubleSide,
                    uniforms: {
                        uTime: {
                            value: 0
                        },
                        uMouse: {
                            value: new THREE.Vector2(0, 0)
                        },
                        uResolution: {
                            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
                        },
                        uProgress: {
                            value: 0
                        },
                        uTexture: {
                            value: null
                        }
                    }
                });
                this.particleExplodeMaterial = particleExplodeMaterial;
            }
            // 创建点
            createPoints() {
                const maku = new Maku(
                    this.image,
                    this.particleExplodeMaterial,
                    this.scene,
                    "points",
                    "size", {
                        width: 128,
                        height: 128
                    }
                );
                maku.setPosition();
                this.maku = maku;
            }
            // 创建后期特效
            createPostprocessingEffect() {
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5,
                    0.4, 0.85);
                this.bloomPass.threshold = this.params.bloomThreshold;
                this.bloomPass.strength = this.params.bloomStrength;
                this.bloomPass.radius = this.params.bloomRadius;
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(this.bloomPass);
            }
            // 创建点击效果
            createClickEffect() {
                const material = this.maku.mesh.material;
                this.image.addEventListener("click", () => {
                    if (!this.isOpen) {
                        gsap.to(material.uniforms.uProgress, {
                            value: 3,
                            duration: 1
                        });
                        this.isOpen = true;
                    } else {
                        gsap.to(material.uniforms.uProgress, {
                            value: 0,
                            duration: 1
                        });
                        this.isOpen = false;
                    }
                });
            }
            // 动画
            update() {
                const elapsedTime = this.clock.getElapsedTime();
                if (this.maku) {
                    const material = this.maku.mesh.material;
                    material.uniforms.uTime.value = elapsedTime;
                    material.uniforms.uMouse.value = this.mousePos;
                }
                this.bloomPass.strength = this.params.bloomStrength;
            }
            // 创建调试面板
            createDebugPanel() {
                const gui = new dat.GUI();
                const material = this.maku.mesh.material;
                const uniforms = material.uniforms;
                const params = this.params;
                gui
                    .add(uniforms.uProgress, "value")
                    .min(0)
                    .max(3)
                    .step(0.01)
                    .name("progress");
                gui.add(params, "bloomStrength").min(0).max(10).step(0.01);
            }
        }
        if (WEBGL.isWebGLAvailable() === false) {
            document.body.appendChild(WEBGL.getWebGLErrorMessage());
        } else {
            const img = new Image();
            const dom = document.querySelector('.container');
            img.setAttribute('crossorigin', 'anonymous');
            img.addEventListener('load', () => {
                new ParticleExplode(dom, img, true).init();
            });
            img.src = 'img/uYcvELkr4dqFj9w.jpeg';
            dom.appendChild(img);
        }

    </script>
</body>

</html>
