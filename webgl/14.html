<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no">
    <title>HLS内球型全景视频</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }
        
        html,
        body {
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        
        .panel {
            overflow: hidden;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 0;
        }
        
        #canvas {
            position: absolute;
        }
    </style>
    <script>
        /*********************************************************************************
         * Utils.js
         * webgl帮助类
         *
         * @version v1.0
         * @copyright 2001-2015 nxiao
         * @author nxiao <363305175@qq.com>
         * @license {@link https://github.com/ningxiao}
         *********************************************************************************/
        var Utils = {};
        /**
         * 检测是否支持touch事件
         * @param bool true 支持 false 不支持
         */
        Utils.IsTouch = "ontouchend" in document ? true : false;
        /**
         * 图片队列加载
         * @param  {[type]} srcs     [description]
         * @param  {[type]} imgs     [description]
         * @param  {[type]} complete [description]
         * @param  {[type]} progress [description]
         * @return {[type]}          [description]
         */
        Utils.QueueImg = function(urls, complete, progress) {
            var key, url, index = arguments[3] || 0;
            var data = urls[index];
            var img = new Image();
            var bitmap = arguments[4] || {};
            for (key in data) {
                url = data[key];
            };
            img.onload = function() {
                bitmap[key] = img;
                index++;
                progress && progress.call(this, {
                    "total": urls.length,
                    "loaded": index
                });
                if (index != urls.length) {
                    Utils.QueueImg.call(this, urls, complete, progress, index, bitmap);
                } else {
                    complete.call(this, bitmap);
                };
            };
            img.crossOrigin = "Anonymous";
            img.src = url;
        };
        /**
         * 获取cavans的2D绘制对象
         * @param {[type]} canvas [description]
         */
        Utils.GetContext = function(canvas) {
            if (canvas) {
                return canvas.getContext('2d');
            };
            return null;
        };
        /**
         * 获取canvas的webgl持有对象
         * @param {canvas} canvas 页面渲染对象
         * @param {boolean} opt_debug  是否开启调试模式
         * @param {function} opt_onerror 获取webgl异常是否存在回调函数
         * @return {gl} 成功返回 canvas 的webgl对象 失败返回 null
         */
        Utils.GetWebGlContext = function(canvas, opt_debug, opt_onerror) {
            var gl, config = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
            opt_onerror = opt_onerror || function(event) {
                console.log(event.statusMessage);
            };
            canvas.addEventListener("webglcontextcreationerror", opt_onerror, false);
            for (var i = 0, l = config.length; i < l; i++) {
                try {
                    gl = canvas.getContext(config[i], {
                        antialias: true,
                        stencil: true
                    });
                } catch (err) {
                    console.log(err);
                };
                if (gl) {
                    break;
                };
            };
            if (!gl) {
                return null;
            };
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            return gl;
        };
        /**
         * 初始化渲染着色器
         * @param {webgl} gl             webgl对象
         * @param {[type]} vertexshader   初始化的顶点着色器
         * @param {[type]} fragmentshader 初始化的片段着色器
         * @return {program} program  成功返回 在js里面的渲染引用 失败返回 null
         */
        Utils.InitShaders = function(gl, vertexshader, fragmentshader) {
            var program, linked;
            if (!vertexshader || !fragmentshader) {
                return;
            };
            //创建 GPU在js的控制对象 program
            program = gl.createProgram();
            if (!program) {
                return;
            };
            //把着顶点色器传递给program
            gl.attachShader(program, vertexshader);
            //把着片源色器传递给program
            gl.attachShader(program, fragmentshader);
            //将program 对象链接到GPU
            gl.linkProgram(program);
            //获取链接并且进行验证
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.log('无法链接WEBGL程序: ' + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                return;
            };
            //开始运行program
            gl.useProgram(program);
            return program;
        };
        /**
         * 缓冲区设置顶点着色器数据
         * @param {webgl} gl   canvas的webgl持有对象
         * @param {program} program   渲染着色器持有对象
         * @param {Float32Array} vertices Float32Array 的顶点数据
         * @param {int} size 顶点数据分量值 2 为x y 3 为x y z
         * @param {string} name 顶点着色器变量名称
         * @return {int} n  成功返回 渲染点的数量 失败返回 0
         */
        Utils.InitVertexBuffers = function(gl, program, vertices, size, name) {
            var n, fsize, position, vertexbuffer;
            if (!(gl && vertices.length > 0 && size && name)) {
                console.log("传入参数错误");
                return 0;
            };
            fsize = vertices.BYTES_PER_ELEMENT;
            n = vertices.length / size;
            //创建一个gl的缓冲区对象
            vertexbuffer = gl.createBuffer();
            if (!vertexbuffer) {
                console.log("创建缓冲区对象失败");
                return 0;
            };
            //将缓冲区对象绑定到gl
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexbuffer);
            //创建一个缓冲区并且将数据写入
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            /**
                //创建一个指定内存大小的缓冲区 只有大小没有数据
                gl.bufferData(gl.ARRAY_BUFFER, fsize * vertices.length, gl.STATIC_DRAW);
                //更新指定区域数据 更新数据类型   更新偏移位置 数据
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
            */
            //获取顶点着色器变量
            position = this.GetGpuLocation(gl, program, name);
            if (position < 0) {
                gl.deleteBuffer(vertexbuffer);
                console.log("获取WebGl顶点变量" + name + "失败");
                return 0;
            };
            //将缓冲区对象分配给着色器变量
            gl.vertexAttribPointer(position, size, gl.FLOAT, false, fsize * size, 0);
            //将顶点变量与分配的缓冲区对象连接起来
            gl.enableVertexAttribArray(position);
            return n;
        };
        /**
         * 读取webgl片段渲染出着色器
         * @param {canvas} webgl canvas的webgl持有对象
         * @param {element} id   页面编写着色器代码的元素对象
         * @return {shader} shader  成功返回 对应着色器对象 失败返回 null
         */
        Utils.GetShader = function(gl, value) {
            var shader, error;
            switch (value.type) {
                case "x-shader/x-fragment": //片源着色器
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                    break;
                case "x-shader/x-vertex": //顶点着色器
                    shader = gl.createShader(gl.VERTEX_SHADER);
                    break;
                default:
                    return;
            };
            if (shader == null) {
                return;
            };
            //绑定着色器字符串到到着色器
            gl.shaderSource(shader, value.text);
            //编译着色器,并且生成着色器
            gl.compileShader(shader);
            //验证着色器创建是否成功
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
                error = gl.getShaderInfoLog(shader);
                console.log('无法编译着色器: ' + error);
                gl.deleteShader(shader);
                return null;
            };
            return shader;
        };

        /**
         * 获取GPU定义的变量引用
         * @param {webgl} gl      webgl对象
         * @param {Program} program   混合好顶点着色与片元着色的着色器
         * @param {String} name    获取对象名称
         * @param {boolean} isbool   false获取顶点片段变量 true获取片源着色器片段域
         * @return {int} 成功返回 是大于或者大于0的变量存储地址 -1为变量地址不存在
         */
        Utils.GetGpuLocation = function(gl, program, name, isbool) {
            if (gl && program) {
                if (isbool) {
                    //获取片源着色器变量失败返回null
                    return gl.getUniformLocation(program, name) || -1;
                };
                //获取顶点着色器变量失败返回-1
                return gl.getAttribLocation(program, name);
            };
            return -1;
        };

        /**
         * 生成一个指定范围的随机数
         * @param {number} min 最小范围
         * @param {number} max 最小范围
         */
        Utils.Random = function(min, max) {
            return Math.floor(min + Math.random() * (max - min));
        };
        /**
         * 传统鼠标的坐标转换为webgl坐标
         * @param  {int} cw   画布中心点
         * @param  {int} ch   画布中心点
         * @param  {int]} rect 画布的坐标
         * @param  {int} cx   鼠标点击x
         * @param  {int} cy   鼠标点击y
         * @return {int}      新的xy坐标
         */
        Utils.LocalToGobal = function(cw, ch, rect, cx, cy) {
            var x = rect.left;
            var y = rect.top;
            x = ((cx - x) - cw) / cw;
            y = (ch - (cy - y)) / ch;
            return new Float32Array([x, y]);
        };
        /**
         * 获取鼠标在当前canvas的坐标
         * @param  {canvas} element [description]
         * @return {[type]}         [description]
         */
        Utils.CaptureMouse = function(element) {
            var mouse = {
                    x: 0,
                    y: 0,
                    event: null
                },
                body_scrollLeft = document.body.scrollLeft,
                element_scrollLeft = document.documentElement.scrollLeft,
                body_scrollTop = document.body.scrollTop,
                element_scrollTop = document.documentElement.scrollTop,
                offsetLeft = element.offsetLeft,
                offsetTop = element.offsetTop;
            element.addEventListener('mousemove', function(event) {
                var x, y;
                if (event.pageX || event.pageY) {
                    x = event.pageX;
                    y = event.pageY;
                } else {
                    x = event.clientX + body_scrollLeft + element_scrollLeft;
                    y = event.clientY + body_scrollTop + element_scrollTop;
                }
                x -= offsetLeft;
                y -= offsetTop;
                mouse.x = x;
                mouse.y = y;
                mouse.event = event;
            }, false);
            return mouse;
        };
        /**
         * 在移动端进行坐标监听
         * @param  {canvas} element [description]
         * @return {[type]}         [description]
         */
        Utils.CaptureTouch = function(element) {
            var touch = {
                    x: null,
                    y: null,
                    isPressed: false,
                    event: null
                },
                body_scrollLeft = document.body.scrollLeft,
                element_scrollLeft = document.documentElement.scrollLeft,
                body_scrollTop = document.body.scrollTop,
                element_scrollTop = document.documentElement.scrollTop,
                offsetLeft = element.offsetLeft,
                offsetTop = element.offsetTop;

            element.addEventListener('touchstart', function(event) {
                touch.isPressed = true;
                touch.event = event;
            }, false);

            element.addEventListener('touchend', function(event) {
                touch.isPressed = false;
                touch.x = null;
                touch.y = null;
                touch.event = event;
            }, false);

            element.addEventListener('touchmove', function(event) {
                var x, y, touch_event = event.touches[0];
                if (touch_event.pageX || touch_event.pageY) {
                    x = touch_event.pageX;
                    y = touch_event.pageY;
                } else {
                    x = touch_event.clientX + body_scrollLeft + element_scrollLeft;
                    y = touch_event.clientY + body_scrollTop + element_scrollTop;
                }
                x -= offsetLeft;
                y -= offsetTop;

                touch.x = x;
                touch.y = y;
                touch.event = event;
            }, false);

            return touch;
        };
        /**
         * [parseColor description]
         * @param  {[type]} color    [description]
         * @param  {[type]} toNumber [description]
         * @return {[type]}          [description]
         */
        Utils.ParseColor = function(color, toNumber) {
            if (toNumber === true) {
                if (typeof color === 'number') {
                    return (color | 0);
                };
                if (typeof color === 'string' && color[0] === '#') {
                    color = color.slice(1);
                };
                return window.parseInt(color, 16);
            } else {
                if (typeof color === 'number') {
                    color = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
                };
                return color;
            };
        };
        /**
         * 将颜色转为rgba
         * @param  {[type]} color [description]
         * @param  {[type]} alpha [description]
         * @return {[type]}       [description]
         */
        Utils.ColorToRGB = function(color, alpha) {
            var r, g, b, a;
            if (typeof color === 'string' && color[0] === '#') {
                color = window.parseInt(color.slice(1), 16);
            };
            alpha = (alpha === undefined) ? 1 : alpha;
            r = color >> 16 & 0xff;
            g = color >> 8 & 0xff;
            b = color & 0xff;
            a = (alpha < 0) ? 0 : ((alpha > 1) ? 1 : alpha);
            if (a === 1) {
                return "rgb(" + r + "," + g + "," + b + ")";
            } else {
                return "rgba(" + r + "," + g + "," + b + "," + a + ")";
            };
        };
        /**
         * 检测某个点是否在指定矩形区域内
         * @param {object} rect {x:0,y:0,width:50,height:50}
         * @param {int} x
         * @param {int} y
         */
        Utils.ContainsPoint = function(rect, x, y) {
            return !(x < rect.x || x > rect.x + rect.width || y < rect.y || y > rect.y + rect.height);
        };
        /**
         * 浏览器帧频对象 获取
         * @return {requestAnimationFrame}           requestAnimationFrame
         */
        window.requestAnimationFrame || (window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) {
            setTimeout(callback, 1000 / 60);
        });

        /**
         * 浏览器帧频对象 关闭
         */
        window.cancelAnimationFrame || (window.cancelAnimationFrame = window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || window.clearTimeout);
    </script>
    <script src="./js/hls.min.js"></script>
    <script src="./js/glmatrix.min.js"></script>
</head>

<body>
    <video id="video"></video>
    <div class="panel">
        <canvas id="canvas" width="100%" height="100%"></canvas>
        <button type="button" id="playbutton" style="position: absolute;">点击播放</button>
    </div>
    <script>
        var shaders = {
            "shader-vs": {
                type: "x-shader/x-vertex",
                text: `
                        attribute vec4 a_position;
                        attribute vec2 uv;
                        varying vec2 vuv;
                        uniform mat4 v_matrix;
                        uniform mat4 m_matrix;
                        uniform mat4 p_matrix;
                        void main(){
                            gl_Position = p_matrix * v_matrix * m_matrix * a_position;
                            vuv = uv;
                        }`
            },
            "shader-fs": {
                type: "x-shader/x-fragment",
                text: `
                        #ifdef GL_ES
                        precision mediump float;//精度限制
                        #endif
                        varying vec2 vuv;
                        uniform sampler2D sampler;
                        void main(){
                            gl_FragColor = texture2D(sampler,vuv);
                        }`
            }
        }
    </script>
    <script>
        (function(exports) {
            var vertex = [];
            var ind = [];
            var step = 2;
            var radius = 400;
            var pi = Math.PI;
            var jstep = 360 / step + 1;
            var sinj, cosj, sini, cosi, sum, sumji;
            var clientrect = document.documentElement.getBoundingClientRect();
            document.addEventListener('touchmove', function(event) {
                event.preventDefault();
            });
            //计算球型的顶点数据 x y z s t
            for (var j = -90, jl = 90; j <= jl; j += step) {
                for (var i = 0, il = 360; i <= il; i += step) {
                    sini = Math.sin(i / 180 * pi);
                    cosi = Math.cos(i / 180 * pi);
                    sinj = Math.sin(j / 180 * pi);
                    cosj = Math.cos(j / 180 * pi);
                    // 动态计算球型三维坐标 x y z
                    vertex.push(radius * cosj * cosi, radius * sinj, radius * cosj * sini);
                    // 动态计算球型贴图纹理坐标 uv 或者 st
                    vertex.push(i / 360, (j / 90) / 2 + 0.5);
                };
            };
            //计算球型的顶点数据索引
            for (i = 0, il = 360 / step; i < il; ++i) {
                for (j = 0, jl = 180 / step; j < jl; j++) {
                    sumji = j * jstep + i;
                    sum = (j + 1) * jstep + i + 1;
                    if (j == 0) {
                        ind.push(sumji, sum, (j + 1) * jstep + i);
                    } else if (j == jl - 1) {
                        ind.push(sumji, sumji + 1, sum);
                    } else {
                        ind.push(sumji, sumji + 1, sum);
                        ind.push(sumji, sum, (j + 1) * jstep + i);
                    };
                };
            };
            exports.config = {
                'width': clientrect.width,
                'height': clientrect.height,
                'indices': new Uint16Array(ind),
                'vertices': new Float32Array(vertex)
            };
        })(typeof exports === 'object' ? exports : window);
        var gl, dots, video, bitmapdata, canvas = document.getElementById('canvas');
        var gltexture, AMORTIZATION = 0.95;
        var dY = 0;
        var dX = 0;
        var old_x, old_y, drag = false;
        var rotationX = 0;
        var rotationY = 0;
        var v_matrix, m_matrix, p_matrix;
        var distance = 70;
        var rotx = 0;
        var roty = 0;

        function createplay() {
            var videodata, mp4source, playbutton;
            playbutton = document.getElementById("playbutton");
            video = document.createElement("video");
            video.autoplay = "autoplay";
            video.controls = "controls";
            //video.setAttribute("playsinline", "true"); //ios 10 支持非全屏播放
            //video.setAttribute("webkit-playsinline", "true"); //解决微信可以不用全屏播放
            videodata = {
                win: {
                    start: 0,
                    length: 10
                }
            };

            if (Hls.isSupported()) {
                var hls = new Hls();
                hls.loadSource('http://127.0.0.1/video/utvr.m3u8');
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    video.play();
                });
            };

            function timeupdatefun() {
                if (this.currentTime > 0) {
                    video.removeEventListener("timeupdate", timeupdatefun);
                    createpgl();
                };
            };
            video.addEventListener("play", function(event) {
                playbutton.style.display = "none";
                videodata["win"]["length"] = this.duration - 31;
            });
            video.addEventListener("ended", function(event) {
                // video.load();
                // video.play();
            });
            video.addEventListener("timeupdate", timeupdatefun);
            playbutton.addEventListener("touchend", function(ev) {
                video.play();
            });
            //video.play();
        };

        function initvertexbuffers(gl, program, vertices, indices, size) {
            var n, uv, fsize, position, indexbuffer, vertexbuffer;
            if (!(gl && vertices.length > 0 && indices.length > 0)) {
                console.log("传入参数错误");
                return 0;
            };
            n = indices.length;
            //获取元素字节大小
            fsize = vertices.BYTES_PER_ELEMENT;
            //创建一个gl的顶点坐标与颜色缓冲区
            vertexbuffer = gl.createBuffer();
            //创建一个gl顶点索引缓冲区
            indexbuffer = gl.createBuffer();
            if (!vertexbuffer || !indexbuffer) {
                console.log("创建缓冲区对象失败");
                return 0;
            };
            //将顶点坐标与颜色缓冲区对象绑定到gl
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexbuffer);
            //将顶点坐标与颜色写入缓冲区对象
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            //获取顶点着色器变量
            position = Utils.GetGpuLocation(gl, program, "a_position");
            uv = Utils.GetGpuLocation(gl, program, "uv");
            if (position < 0 || uv < 0) {
                gl.deleteBuffer(vertexbuffer);
                gl.deleteBuffer(indexbuffer);
                console.log("获取WebGl顶点变量失败");
                return 0;
            };
            //将缓冲区对象分配给着色器变量 坐标数据
            gl.vertexAttribPointer(position, 3, gl.FLOAT, false, fsize * size, 0);
            //将顶点变量与分配的缓冲区对象连接起来
            gl.enableVertexAttribArray(position);
            //将缓冲区对象分配给着色器变量
            gl.vertexAttribPointer(uv, 2, gl.FLOAT, false, fsize * size, fsize * 3);
            //将顶点变量与分配的缓冲区对象连接起来
            gl.enableVertexAttribArray(uv);
            //将顶点索引缓冲区对象绑定到gl
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuffer);
            //将顶点索引写入缓冲区对象
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            return n;
        };

        function inittextures(gl, program, name, bitmap, index) {
            //创建纹理对象
            var u_sampler, texture = gl.createTexture();
            var index = index || 0;
            if (!texture) {
                console.log("创建纹理对象失败");
                return;
            };
            u_sampler = Utils.GetGpuLocation(gl, program, name, true);
            if (u_sampler < 0) {
                gl.deleteTexture(texture);
                console.log("获取WebGl片源变量u_Sampler失败");
                return;
            };
            //将纹理图片反转
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            //开启0号纹理单元
            gl.activeTexture(gl["TEXTURE" + index]);
            //将创建的纹理单元绑定
            gl.bindTexture(gl.TEXTURE_2D, texture);
            //配置纹理参数
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            //将img绑定到纹理
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);
            //将0号纹理传递给着色器
            gl.uniform1i(u_sampler, index);
            return texture;
        };

        function drawgl() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            //清理之前颜色和深度模型
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            video.paused || gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            mat4.identity(mmatrix); //重置模型矩阵
            mat4.rotateX(mmatrix, mmatrix, roty);
            mat4.rotateY(mmatrix, mmatrix, rotx);

            mat4.identity(vmatrix); //视图模型矩阵
            mat4.lookAt(vmatrix, [0, 0, distance], [0, 0, 1000], [0, 1, 0]);

            gl.uniformMatrix4fv(v_matrix, false, vmatrix);

            gl.uniformMatrix4fv(m_matrix, false, mmatrix);
            //绘制一个点
            gl.drawElements(gl.TRIANGLES, dots, gl.UNSIGNED_SHORT, 0);
            //清除马上执行
            gl.flush();
            requestAnimationFrame(drawgl, canvas);
        };

        function mousecall() {
            var beta, old_beta = 0;

            function mousedown(ev) {
                drag = true;
                event.preventDefault();
                ev = (ev.touches && ev.touches[0]) || ev;
                old_x = ev.clientX, old_y = ev.clientY;
                return false;
            };

            function mouseup(ev) {
                drag = false;
            };

            function mousemove(ev) {
                if (!drag) return false;
                ev.preventDefault();
                ev = (ev.touches && ev.touches[0]) || ev;
                dX = ev.clientX;
                dY = ev.clientY;
                rotationX += (old_x - dX) / 4;
                rotationY -= (old_y - dY) / 4;
                if (rotationX >= 360) rotationX -= 360;
                if (rotationX < 0) rotationX += 360;
                rotationY = Math.min(rotationY, 90);
                rotationY = Math.max(rotationY, -90);
                rotx = rotationX * Math.PI / 180;
                roty = rotationY * Math.PI / 180;
                old_x = dX;
                old_y = dY;
            };

            function mousewheel(ev) {
                var delta = ev.detail ? -ev.detail / 3 : ev.wheelDelta / 120;
                distance -= delta * 4;
                distance = Math.min(distance, 900);
                distance = Math.max(distance, -300);
            };

            function resizecall(ev) {
                setTimeout(function() {
                    var clientrect = document.documentElement.getBoundingClientRect();
                    canvas.setAttribute('width', clientrect.width);
                    canvas.setAttribute('height', clientrect.height);
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    mat4.identity(pmatrix); //重置模型矩阵
                    mat4.perspective(pmatrix, Math.PI * 60 / 180, clientrect.width / clientrect.height, 1, 800);
                    gl.uniformMatrix4fv(p_matrix, false, pmatrix);
                }, 200);
            };

            function orientationhandler(ev) {
                if (ev.beta != null) {
                    beta = ev.beta.toFixed(2);
                    if (Math.abs(Math.abs(beta) - Math.abs(old_beta)) > 0.98) {
                        rotationY = old_beta = beta - 90;
                    };
                    rotx = rotationX * Math.PI / 180;
                    roty = rotationY * Math.PI / 180;
                };
            };
            canvas.addEventListener("mousedown", mousedown, false);
            canvas.addEventListener("mouseup", mouseup, false);
            canvas.addEventListener("mouseout", mouseup, false);
            canvas.addEventListener("mousemove", mousemove, false);
            canvas.addEventListener("mousewheel", mousewheel, false);
            canvas.addEventListener('DOMMouseScroll', mousewheel, false);

            canvas.addEventListener("touchstart", mousedown, false);
            canvas.addEventListener("touchend", mouseup, false);
            canvas.addEventListener("touchmove", mousemove, false);
            window.addEventListener("resize", resizecall, false);
            if (window.DeviceOrientationEvent) {
                window.addEventListener("deviceorientation", orientationhandler, false);
            };
        };

        function createpgl() {
            //获取顶点着色代码并且编译生成
            var shadervs = Utils.GetShader(gl, shaders['shader-vs']);
            //获取片元着色代码并且编译生成
            var shaderfs = Utils.GetShader(gl, shaders['shader-fs']);
            //将顶点着色与片元着色交由着色器生成
            var program = Utils.InitShaders(gl, shadervs, shaderfs);
            if (!program) {
                console.log("生成着色器失败！");
                return;
            };
            //返回渲染顶点数量
            dots = initvertexbuffers(gl, program, config.vertices, config.indices, 5);
            //渲染视频纹理
            gltexture = inittextures(gl, program, "sampler", video, 0);
            if (!gltexture) {
                console.log("设置纹理0号失败");
                return;
            };
            v_matrix = Utils.GetGpuLocation(gl, program, 'v_matrix', true);
            m_matrix = Utils.GetGpuLocation(gl, program, 'm_matrix', true);
            p_matrix = Utils.GetGpuLocation(gl, program, 'p_matrix', true);
            if (v_matrix < 0 || m_matrix < 0 || p_matrix < 0) {
                console.log("获取WebGl顶点矩阵变量失败");
                return;
            };
            vmatrix = mat4.create(); //视图矩阵
            mmatrix = mat4.create(); //模型矩阵
            pmatrix = mat4.create(); //投影矩阵
            mat4.rotateY(mmatrix, mmatrix, rotx);
            mat4.rotateX(mmatrix, mmatrix, roty);
            mat4.lookAt(vmatrix, new Float32Array([0, 0, distance]), new Float32Array([0, 0, 1000]), new Float32Array([0, 1, 0]));
            mat4.perspective(pmatrix, Math.PI * 60 / 180, config.width / config.height, 1, 800);

            gl.uniformMatrix4fv(v_matrix, false, vmatrix);
            gl.uniformMatrix4fv(m_matrix, false, mmatrix);
            gl.uniformMatrix4fv(p_matrix, false, pmatrix);

            //开启隐藏面消除
            gl.enable(gl.DEPTH_TEST);
            mousecall();
            drawgl();
        };
        canvas.setAttribute('width', config.width);
        canvas.setAttribute('height', config.height);
        gl = Utils.GetWebGlContext(canvas);
        if (gl) {
            // Utils.QueueImg([{
            //     "bfvr": "./image/bfvr.jpg"
            // }], function(bitmaps) {
            //     video = bitmaps["bfvr"];
            //     createpgl();
            // });
            createplay();
        } else {
            console.log("开始webgl失败");
        };
    </script>
    <!--
    <script>
        if (Hls.isSupported()) {
            var video = document.getElementById('video');
            var hls = new Hls();
            hls.loadSource('https://video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8');
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                console.log("---");
                video.play();
            });
        }
    </script>
-->
</body>

</html>