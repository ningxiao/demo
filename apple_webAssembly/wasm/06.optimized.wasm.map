{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/06.ts"],"names":[],"mappings":"sGEKqB,GAAU,YAEV,AAHA,GAAS,UAGI,AADlB,SAAO,AAAI,AAAI,EAAJ,KAAW,AAAI,EAAJ,kBAEnB,SAAM,MACD,cACC,EAAI,KACL,AAAC,GAAI,GAAc,KACrB,AAAC,AAAI,EAAJ,GAAc,KACX,MAAG,EAAI,KACV,GAAI,GAAQ,KAEd,sBACY,QACd,AAAC,AAAO,EAAK,KAAO,AAAO,EAAK,MAAO,aACrC,SAAM,GAAK,GAAK,KAChB,EAAO,GAAO,KACf,EAAa,KACf,aAGC,EAAY,KACH,EAAK,GAAK,EAAK,IAAK,KAC3B,SAAM,GAAK,GAAK,KAChB,IACH,WAWgB,EAAK,GAAhB,GAJP,AADa,EAAK,GAAK,EAAK,MACf,YAEA,SAQd,AAAI,AAR+C,EAAY,IAAI,AADzC,SAAM,AAAS,QACsC,GAQpE,UAAW,oBAjCK,WAHH","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","/** Number of discrete color values on the JS side. */\nconst NUM_COLORS = 2048;\n/** Updates the rectangle `width` x `height`. */\nexport function update(width: u32, height: u32, limit: u32): void {\n    var translateX = width * (1.0 / 1.6);\n    var translateY = height * (1.0 / 2.0);\n    var scale = 10.0 / min(3 * width, 4 * height);\n    var realOffset = translateX * scale;\n    var invLimit = 1.0 / limit;\n    var minIterations = min(8, limit);\n    for (let y: u32 = 0; y < height; ++y) {\n        let imaginary = (y - translateY) * scale;\n        let yOffset = (y * width) << 1;\n        for (let x: u32 = 0; x < width; ++x) {\n            let real = x * scale - realOffset;\n            // Iterate until either the escape radius or iteration limit is exceeded\n            let ix = 0.0, iy = 0.0, ixSq: f64, iySq: f64;\n            let iteration: u32 = 0;\n            while ((ixSq = ix * ix) + (iySq = iy * iy) <= 4.0) {\n                iy = 2.0 * ix * iy + imaginary;\n                ix = ixSq - iySq + real;\n                if (iteration >= limit) break;\n                ++iteration;\n            }\n            // Do a few extra iterations for quick escapes to reduce error margin\n            while (iteration < minIterations) {\n                let ixNew = ix * ix - iy * iy + real;\n                iy = 2.0 * ix * iy + imaginary;\n                ix = ixNew;\n                ++iteration;\n            }\n            // Iteration count is a discrete value in the range [0, limit] here, but we'd like it to be\n            // normalized in the range [0, 2047] so it maps to the gradient computed in JS.\n            // see also: http://linas.org/art-gallery/escape/escape.html\n            let colorIndex = NUM_COLORS - 1;\n            let distanceSq = ix * ix + iy * iy;\n            if (distanceSq > 1.0) {\n                let fraction = Math.log2(0.5 * Math.log(distanceSq));\n                colorIndex = <u32>((NUM_COLORS - 1) * clamp<f64>((iteration + 1 - fraction) * invLimit, 0.0, 1.0));\n            }\n            store<u16>(yOffset + (x << 1), colorIndex);\n        }\n    }\n}\n/** Clamps a value between the given minimum and maximum. */\nfunction clamp<T>(value: T, minValue: T, maxValue: T): T {\n    return min(max(value, minValue), maxValue);\n}\n"]}